## 多线程

### 1 基础知识

#### 1.1 进程

进程是指在系统中正在运行的一个应用程序，每个进程之间是独立的，每个进程之间是独立的，每个进程均运行在其专用且受保护的内存空间内。<br/><br/>

#### 1.2 线程

1个进程想要执行任务，必须得有线程，也就是每1个进程至少要有1条线程，称为主线程。一个进程的所有任务都在线程中执行。<br/><br/>

#### 1.3 进程和线程的比较

线程是CPU调用（执行任务）的最小单位。

进程是CPU分配资源的最小单位。

一个进程中至少要有一个线程。

同一个进程内的线程共享进程的资源。<br/><br/>

#### 1.4 线程的串行

1个线程中任务的执行是串行的，如果要在1个线程中执行多个任务，那么只能一个一个按顺序执行。也就是同一时间内，1个线程只能执行1个任务。<br/><br/>

#### 1.5 多线程

1个进程中可以开启多条线程，每条线程可以并行（同时）执行不同的任务，多线程技术可以提高程序的执行效率。<br/><br/>

#### 1.6 多线程原理

同一时间，CPU只能处理1条线程，只有1条线程在工作（执行），多线程并发（同时）执行不同的任务，其实是CPU快速地在多条线程之间调度（切换），如果CPU调度线程的时间足够快，就造成了多线程并发执行的假象。

如果开启的线程非常非常多，CPU会在N多线程之间调度，CPU会累死，消耗大量的CPU资源，同时每条线程被调用执行的频次也会降低（线程的执行效率降低）。<br/><br/>

#### 1.7 多线程的优缺点

优点：

- 能适当提高程序的执行效率

- 能适当提高资源利用率（CPU、内存利用率）


缺点：

- 创建线程是有开销的，iOS下主要成本包括：内核数据结构（大约1KB）、栈空间（子线程512KB、主线程1MB，也可以使用-setStackSize：设置，但必须是4K的倍数，而且最小是16K），创建线程大约需要90毫秒的创建时间。

- 如果开启大量的线程，会降低程序的性能，线程越多，CPU在调度线程上的开销就越大。

- 程序设计更加复杂：比如线程之间的通信、多线程的数据共享等问题。<br/><br/>


#### 1.8 多线程的应用

主线程的主要作用

显示/刷新UI界面

处理UI事件（比如点击、滚动、拖拽事件等）

主线程使用注意：

别将比较耗时的操作放到主线程中

耗时操作会卡住主线程，严重影响UI的流程度，影响用户体验。

将耗时操作放在子线程执行，然后到刷新UI时再换回主线程。<br/><br/>

#### 1.9 iOS的4种多线程方案

| 方案        | 简介                                                         | 语言 | 线程生命周期 | 使用频率 |
| ----------- | ------------------------------------------------------------ | ---- | ------------ | -------- |
| pthread     | 一套通用的多线程API<br/>适用于Unix\Linux\Windows等系统<br/>跨平台\可移植<br/>使用难度大 | C    | 程序员管理   | 几乎不用 |
| NSThread    | 使用更加面向对象<br/>简单易用，可直接操作线程对象            | OC   | 程序员管理   | 偶尔使用 |
| GCD         | 旨在替代NSThread等线程技术                                   | C    | 自动管理     | 经常使用 |
| NSOperation | 基于GCD封装<br/>比GCD多了一些更简单实用的功能<br/>实用更加面向对象 | OC   | 自动管理     | 经常使用 |

<br/>

### 2 pthread

#### 2.1 pthread简介

pthread是一套通用的多线程的API，可以在Unix/Linux/Windows等系统跨平台使用，使用C语言编写，需要程序员管理线程的生命周期，使用难度大，iOS开发中几乎不使用pthread。仅做了解。<br/><br/>

#### 2.2 pthread使用

需要引入头文件`#import <pthread.h>`

需要创建线程并开启线程任务

代码如下：

```
- (void)pthreadRun {
    // 创建线程 定义pthread_t变量
    pthread_t thread;
    // 开启线程 执行任务
    pthread_create(&thread, NULL, run, NULL);
    // 设置子线程的状态设置为detached，该线程运行结束后会自动释放所有资源
    pthread_detach(thread);
}

void *run(void *param) {
    NSLog(@"pthread - %@", [NSThread currentThread]);
    
    return NULL;
}
```

其中`pthread_create(&thread, NULL, run, NULL);` 的参数定义：

- 第一个参数`&thread`是指线程对象，指向线程标识符的指针
- 第二个是线程属性，可赋值NULL
- 第三个`run`是指向函数的指针（run对应函数里是需要在新线程中执行的任务）
- 第四个是运行函数的参数，可赋值NULL

<br/><br/>

#### 2.3 pthread其他相关方法

```
pthread_create() 创建一个线程
pthread_exit() 终止当前线程
pthread_cancel() 中断另外一个线程的运行
pthread_join() 阻塞当前的线程，直到另外一个线程运行结束
pthread_attr_init() 初始化线程的属性
pthread_attr_setdetachstate() 设置脱离状态的属性（决定这个线程在终止时是否可以被结合）
pthread_attr_getdetachstate() 获取脱离状态的属性
pthread_attr_destroy() 删除线程的属性
pthread_kill() 向线程发送一个信号，线程间发送消息
```

<br/><br/>

### 3 NSThread

#### 3.1 NSThread简介

NSThread是苹果官方提供的，使用起来比pthread更加面向对象，简单易用，可以直接操作线程对象，不过也需要程序员自己管理线程的生命周期（主要是创建），iOS开发过程中偶尔使用NSThread，比如查询当前线程`[NSThread currentThread];`来显示当前线程，或者`[NSThread isMainThread];`来判断当前线程是不是主线程。

<br /><br />

#### 3.2 NSThread使用

需要创建线程并启动线程

代码如下：

```
// 创建并启动
- (void)nsthreadRun {
    // 创建线程 - 关联方法
    NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(nsthreadRunAction) object:nil];
    // 启动线程
    [thread start];
}

- (void)nsthreadRunAction {
    NSLog(@"NSThread - %@", [NSThread currentThread]);
}
```

也可以创建线程后自动启动

```
- (void)nsthreadRun {
    // 创建线程后自动执行方法
    [NSThread detachNewThreadSelector:@selector(nsthreadRunAction) toTarget:self withObject:nil];
    
}
```

或者隐式创建并启动线程

```
- (void)nsthreadRun {
    // 隐式创建并启动线程 该方法是NSObject的分类NSThreadPerformAdditions中实现的
    [self performSelectorInBackground:@selector(nsthreadRunAction) withObject:nil];
    
}
```

<br /><br />

#### 3.3 部分接口

```
// 获取主线程
+ (NSThread *)mainThread;

// 判断是否是主线程-实例方法
- (BOOL)isMainThread;

// 判断是否是主线程-类方法
+ (BOOL)isMainThread;

// 获取当前线程
[NSThread currentThread];

// name的获取和设置方法
@property (nullable, copy) NSString *name;

// 启动线程
- (void)start;

// 阻塞线程方法
+ (void)sleepUntilDate:(NSDate *)date;
+ (void)sleepForTimeInterval:(NSTimeInterval)ti;

// 强制停止线程 线程将进入死亡状态
+ (void)exit;
```

<br /><br />

#### 3.4 线程间通讯

开发中，我们经常需要在子线程做复杂操作，操作结束后再换到主线程刷新UI。

下面通过子线程下载图片，然后主线程显示的例子来说明，代码如下：

```
- (void)dosomeAsyncAction {
    [NSThread detachNewThreadSelector:@selector(donwlaodImage) toTarget:self withObject:nil];
}

- (void)donwlaodImage {
    // 耗时操作 子线程执行
    NSURL *imageUrl = [NSURL URLWithString:@"https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=1764734306,495704103&fm=26&gp=0.jpg"];
    
    NSData *imageData = [NSData dataWithContentsOfURL:imageUrl];
    
    UIImage *image = [UIImage imageWithData:imageData];
    
    // 回到主线程
    [self performSelectorOnMainThread:@selector(renderImageView:) withObject:image waitUntilDone:NO];
    
}

- (void)renderImageView:(UIImage *)image {
    NSLog(@"renderImageView - %@", [NSThread currentThread]);
    // 更新UI
    self.imageView.image = image;
}

```

<br /><br />

#### 3.5 NSThread线程安全和线程同步

**线程安全**：如果你的代码所在的进程中有多个线程在同时进行，这些线程可能会同时运行同一段代码，如果每次运行结果和单线程去运行的结果是一样的，而且其中变量的值也和预期的是一样的，那就是线程安全的。

如果每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的。如果有多个线程同时操作写操作，更改其值，一般都需要考虑线程同步的情况，否则就可能影响线程安全。

**线程同步**：可以理解成线程A和线程B一块配合，A执行到一定程度时要依靠线程B的某个结果，于是停下来，让B运行，此时B运行后将结果给到A，A再继续操作。

举个例子：两个人一起聊天，两个人不能同时说话，避免听不清的情况，等一个人说完9（一个线程结束），另外一个人再说（另一个线程再开始）。

<br /><br />

下面，通过火车票售票的方式，实现NSThread线程安全和解决线程同步问题。

场景：一共有50张火车票，有两个地方的售票口。这两个窗口同时售卖火车票，售完为止。

##### 3.5.1 线程不安全

先来看下正常不加锁的情况下：

```
- (void)threadSafe {
    // 初始50张票
    self.ticketCount = 50;
    
    // 两个售票口
    NSThread *thread1 = [[NSThread alloc] initWithTarget:self selector:@selector(buyTicket) object:nil];
    thread1.name = @"售票口1";
    NSThread *thread2 = [[NSThread alloc] initWithTarget:self selector:@selector(buyTicket) object:nil];
    thread2.name = @"售票口2";
    
    // 开始售卖票
    [thread1 start];
    [thread2 start];
    
}

- (void)buyTicket {
    while (1) {
        if (self.ticketCount > 0) {
            self.ticketCount--;
            [NSThread sleepForTimeInterval:0.2
             ];
            NSLog(@"剩余票数为：%d  thread:%@", self.ticketCount, [NSThread currentThread]);
        }
        if (self.ticketCount <= 0) {
            NSLog(@"票卖完了");
            break;
        }
    }
}
```

输出如下：

```
2020-07-11 11:14:03.205568+0800 test19[2267:125975] 剩余票数为：48  thread:<NSThread: 0x600003cc0240>{number = 8, name = 售票口2}
2020-07-11 11:14:03.205502+0800 test19[2267:125974] 剩余票数为：48  thread:<NSThread: 0x600003cc0300>{number = 7, name = 售票口1}
2020-07-11 11:14:03.407066+0800 test19[2267:125974] 剩余票数为：46  thread:<NSThread: 0x600003cc0300>{number = 7, name = 售票口1}
2020-07-11 11:14:03.407072+0800 test19[2267:125975] 剩余票数为：46  thread:<NSThread: 0x600003cc0240>{number = 8, name = 售票口2}
......
2020-07-11 11:14:08.478901+0800 test19[2267:125974] 剩余票数为：1  thread:<NSThread: 0x600003cc0300>{number = 7, name = 售票口1}
2020-07-11 11:14:08.479106+0800 test19[2267:125974] 票卖完了
2020-07-11 11:14:08.680280+0800 test19[2267:125975] 剩余票数为：0  thread:<NSThread: 0x600003cc0240>{number = 8, name = 售票口2}
2020-07-11 11:14:08.680526+0800 test19[2267:125975] 票卖完了
```

从输出看，票数是乱的，显然不符合预期要求，所以需要考虑线程安全的问题。<br /><br />

##### 3.5.1 线程安全

线程安全的解决方案一般是给线程加锁，在一个线程执行该操作时，不允许其他线程进行操作。

iOS实现线程加锁有多种方式：@synchronized、NSLock...等等，加锁后续会用单独的篇章进行梳理。

现在先用NSLock进行加锁处理。

代码如下：

```
- (void)threadSafe {
    
    // 初始化NSLock
    self.lock = [[NSLock alloc] init];
    
    // 初始50张票
    self.ticketCount = 50;
    
    // 两个售票口
    NSThread *thread1 = [[NSThread alloc] initWithTarget:self selector:@selector(buyTicket) object:nil];
    thread1.name = @"售票口1";
    NSThread *thread2 = [[NSThread alloc] initWithTarget:self selector:@selector(buyTicket) object:nil];
    thread2.name = @"售票口2";
    
    // 开始售卖票
    [thread1 start];
    [thread2 start];
    
}

- (void)buyTicket {
    while (1) {
    		// 加锁
        [self.lock lock];
        if (self.ticketCount > 0) {
            self.ticketCount--;
            [NSThread sleepForTimeInterval:0.1
             ];
            NSLog(@"剩余票数为：%d  thread:%@", self.ticketCount, [NSThread currentThread]);
        }
        // 解锁
        [self.lock unlock];
        
        if (self.ticketCount <= 0) {
            NSLog(@"票卖完了");
            break;
        }
    }
}
```

输出如下：

```
2020-07-11 11:19:22.930366+0800 test19[2300:131552] 剩余票数为：49  thread:<NSThread: 0x600002fec300>{number = 7, name = 售票口1}
2020-07-11 11:19:23.036924+0800 test19[2300:131552] 剩余票数为：48  thread:<NSThread: 0x600002fec300>{number = 7, name = 售票口1}
2020-07-11 11:19:23.139949+0800 test19[2300:131552] 剩余票数为：47  thread:<NSThread: 0x600002fec300>{number = 7, name = 售票口1}
2020-07-11 11:19:23.245209+0800 test19[2300:131552] 剩余票数为：46  thread:<NSThread: 0x600002fec300>{number = 7, name = 售票口1}
......
2020-07-11 11:19:27.358242+0800 test19[2300:131553] 剩余票数为：6  thread:<NSThread: 0x600002fec240>{number = 8, name = 售票口2}
2020-07-11 11:19:27.460865+0800 test19[2300:131552] 剩余票数为：5  thread:<NSThread: 0x600002fec300>{number = 7, name = 售票口1}
2020-07-11 11:19:27.562626+0800 test19[2300:131552] 剩余票数为：4  thread:<NSThread: 0x600002fec300>{number = 7, name = 售票口1}
2020-07-11 11:19:27.664041+0800 test19[2300:131552] 剩余票数为：3  thread:<NSThread: 0x600002fec300>{number = 7, name = 售票口1}
2020-07-11 11:19:27.764513+0800 test19[2300:131552] 剩余票数为：2  thread:<NSThread: 0x600002fec300>{number = 7, name = 售票口1}
2020-07-11 11:19:27.866442+0800 test19[2300:131552] 剩余票数为：1  thread:<NSThread: 0x600002fec300>{number = 7, name = 售票口1}
2020-07-11 11:19:27.966969+0800 test19[2300:131552] 剩余票数为：0  thread:<NSThread: 0x600002fec300>{number = 7, name = 售票口1}
2020-07-11 11:19:27.967307+0800 test19[2300:131552] 票卖完了
2020-07-11 11:19:27.967419+0800 test19[2300:131553] 票卖完了

```

加锁后，得到的剩余票数是正确的，解决了多个线程同步的问题。<br /><br />

#### 3.6 线程的状态转换

当新建一条线程时，在内存中的表现为：

![](https://github.com/tangshenghao/iOSInterviewNotes/blob/master/iOS%E5%9F%BA%E7%A1%80/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%811.jpg?raw=true)

当调用启动线程后，系统把线程对象放入可调度线程池中，线程对象进入就绪状态，如下图：

![](https://github.com/tangshenghao/iOSInterviewNotes/blob/master/iOS%E5%9F%BA%E7%A1%80/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%812.jpg?raw=true)

同时，可调度线程池中可能有其他线程对象，如图：

![](https://github.com/tangshenghao/iOSInterviewNotes/blob/master/iOS%E5%9F%BA%E7%A1%80/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%813.jpg?raw=true)

线程的状态装换：

- 如果CPU现在调度当前线程对象，则当前线程对象进入运行状态，如果CPU调度其他线程对象，则当前线程对象回到就绪状态。
- 如果CPU在运行当前线程对象的时候调用了sleep方法\等到同步锁，则当前线程对象就进入了人阻塞状态，等到sleep到时\得到同步锁，则回到就绪状态。
- 如果CPU在运行当前线程对象的时候线程任务执行完毕\异常强制退出，则当前线程对象进入死亡状态。

整个过程如下图：

![](https://github.com/tangshenghao/iOSInterviewNotes/blob/master/iOS%E5%9F%BA%E7%A1%80/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%814.jpg?raw=true)

