## 面试记录

### 1 TME 一面

电话 -  30min 面试官人很好，各种提示。



- **int 类型占多大**

和机器环境相关，iOS中占4个字节。

编译器可以根据自身硬件来选择合适的大小，但是需要满足约束：short和int至少为16位，long型至少为32位，并且short长度不能超过int，int不能超过long。当前主流的GCC编译器，32位机器和64位机器都是4个字节。



- **一个NSObject实例占多大**

系统分配了16个字节给NSObject对象（通过malloc_size函数获得）

NSObject对象内部只使用了8个字节的空间（64bit环境下，可以通过class_getInstanceSize函数获得）

因为底层里面，NSObject的对象就是一个内部只有一个指向Class的指针的结构体。一个指针占8个字节。（32位占4个字节，64位上占8个字节）。所以实际用到的就是8个字节。

但是alloc的过程中，instanceSize方法内会给小于16字节的对象分配16字节的内存大小。OC中对象最小内存空间大小是16字节。



- **简单说下栈和堆**

栈：编译器自动分配释放，不需要程序员手动管理。先入后出的数据结构。一般存放int、float等值类型。

堆：释放需要程序员管理。存储OC对象，引用类型。



- **堆实际上是什么结构**

堆通常可以看做是一棵树的数组对象。

满足以下性质：

堆中某个字节的值总是不大于或不小于其父节点的值。

堆总是一棵完全二叉树。

跟节点最大或最小，分别叫做大根堆、小根堆。

相当于一维数组，有两个直接后继。



- **什么是字节序，大端字节序，小端字节序**

字节序就是多字节数据在计算机内存中存储或者网络传输时各字节的存储顺序。

一般分为大端字节序和小端字节序。一般来说0x2211使用两个字节存储：高位字节是0x22，低位字节是0x11。

大端字节序：高位字节在前，低位字节在后。

小端字节序：低位字节在前，高位字节在后。即以0x1122形式储存。

为什么不是统一大端字节序。为什么要有小端字节序？

计算机电路先处理低位字节，效率比较高，因为计算都是从低位开始的。所以，计算机的内部处理都是小端字节序。

但是，人类还是习惯读写大端字节序。所以，除了计算机内部处理，其他场合基本都是大端字节序。只有读取的时候，才必须区分字节序，其他情况都不用考虑。



- swift中Array和OC的NSArray的区别

Swift中是值类型，NSArray是引用类型。



- 值类型和引用类型分别适合什么场景

值类型每个实例都有其数据的一份副本，当被赋值给一个变量或常量，或传递给一个函数的时候，它会建立一份新的副本。

引用类型共享一个数据副本。当被赋值给一个变量或常量，或传递给一个函数的时候，一个引用类型一旦被初始化，会返回一个指向已存在实例的引用。

以下时候使用值类型：

想要用==比较实例数据。一个双等号用于比较值。

想复制来建立独立数据。

数据要在多线程的代码中使用，那么你就不用担心数据会被其他线程改变。

以下时候使用引用类型：

想用===比较实例一致性。===会检查两个对象是否完全一致，包括存储数据的内存地址。

你想要创建用于共享，可改变的数据。

值类型存储在栈中。引用类型存储在堆中。



- **简单说下HTTPS，随便拓展**

[HTTPS相关知识](https://github.com/tangshenghao/iOSInterviewNotes/blob/master/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/HTTP/HTTP.md)



- **证书怎么验证**

客户端取出提前内置在手机内部的认证机构的公钥。

用认证机构的公钥去解密公钥证书里面的数字签名。从而得到数字指纹。

客户端对公钥证书的服务器公钥进行数字摘要算法，从而生成数字指纹。

对比客户端自己生成的数字指纹和解密得到的数字指纹是否一致，如果一致则公钥证书验证通过，就可以进行后续的步骤。



- **怎么防止中间人代理**

需要验证证书是否是属于服务器的证书。



除了客户端保存一份证书与服务器的对比验证外，还有什么方式验证服务器证书

可以通过HTTP的接口获取服务器证书的数字指纹。（我后面猜的，具体答案我也还没想到）



- **GCD是怎么实现多线程操作的**

[GCD相关知识](https://github.com/tangshenghao/iOSInterviewNotes/blob/master/iOS%E5%9F%BA%E7%A1%80/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B.md)



- **简单说下循环引用，原因和举例**

循环引用，主要是持有关系产生了环，导致不能正常释放。

比如持有block属性后，在block中使用本类。

代理使用strong来修饰。

NSTimer中target直接使用self等。



- **NSTimer怎么解除循环引用**

在知道target要销毁前，手动执行NSTimer的Invalidate和置nil。

通过WeakProxy的方式，弱引用self，通过消息转发的方式执行消息。



**后面是音视频相关**

- **解释下RGB和YUV**

RGB就是正常的三原色，通过3个字节显示出颜色，做为一个像素。

YUV是通过Y的亮暗程度，和U、V的偏色形成图像，YUV之间有比例，4:4:4或4:2:2或4:2:0等。

[音视频基础知识](https://github.com/tangshenghao/iOSInterviewNotes/blob/master/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%9B%B8%E5%85%B3/%E8%A7%86%E9%A2%91H264%E7%BC%96%E8%A7%A3%E7%A0%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.md)



- **计算一下宽10高10的RGB多大。YUV多大。**

RGB：3个字节 * 10 * 10 = 300Byte

YUV：以4:2:0的比例来说，1个字节 * 10 * 10 + （前面的一半） = 150Byte。（50%的压缩率）



- **音频PCM编码过程**

[音频基础知识](https://github.com/tangshenghao/iOSInterviewNotes/blob/master/%E9%9F%B3%E8%A7%86%E9%A2%91%E7%9B%B8%E5%85%B3/%E9%9F%B3%E9%A2%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.md)



- **计算一下双声道8000Hz 16位 1分钟是多大**

16位 * 60 * 8000 * 2 = 15360000位 = 1920000字节 = 1875K



- **OC中的字典底层是怎么样？**

底层使用的是hash表来实现key和value之间的映射和存储。



- **字典的优点是什么？**

取值的时间复杂度是O(1)



- **什么结构取值也是O(1)**

数组



- **哈希表其实是什么结构？**

hash表其实是一个数组，区别数组的地方是它会建立存储的值到存储的下标索引的一个映射，也就是散列函数。

举例依次把3、12、24、30依次存入hash表中。假设映射关系是存储的索引下标 = 存储值 % hash表长度。



- **哈希表是怎么实现下标不是数字？**

通过散列函数来形成映射关系，来确定下标。



- **怎么解决哈希冲突？**

开放地址法：

使用一种探测方式在整个数组中找到另一个可以存储的地方。



链表法：

将链表和数组相结合，遇到哈希冲突，则将冲突的值加到链表中即可。



- **解决的两种方式的优缺点是什么？如果频繁存储应该使用那种？**

开放地址法：

容易产生堆积问题，不适合大规模的数据储存。插入时可能会多次冲突，删除的元素可能是多个冲突元素中的一个，需要对后面的元素作处理，实现较复杂。结点规模很大时会浪费很多空间。

链表法：

处理冲突简单，且无堆积现象，平均查找长度端。链表中的结点是动态申请的，适合构造表不能确定长度的情况。相对而言，链表法指针域可以忽略不计，因此较开放地址法更加节省空间。



