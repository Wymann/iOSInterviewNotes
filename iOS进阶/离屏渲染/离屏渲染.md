## 离屏渲染

### 1 离屏渲染简介

#### 1.1 离屏渲染具体过程

通常的渲染流程如下图：



APP通过CPU和GPU的合作，不停地将内容渲染完成放入Framebuffer帧缓冲器中，而显示屏幕不断地从Framebuffer中获取内容，显示实时的内容。

而离屏渲染的流程如下图：



与普通的情况下GPU直接将渲染好的内容放入Framebuffer中不同，需要先额外创建离屏渲染缓冲区Offscreen Buffer，将提前渲染好的内容放入其中，等到合适的时机再将Offscreen Buffer中的内容进一步叠加、渲染，完成后将结果切换到Framebuffer中。



#### 1.2 离屏渲染的效率问题

从上面的流程来看，离屏渲染时由于APP需要提前对部分内容进行额外的渲染并保存到Offscreen Buffer，以及需要在必要时刻对Offscreen Buffer和Framebuffer进行内容切换，所以会需要更长的处理时间（实际上这两步关于buffer的切换代价都非常大）。

并且Offscreen Buffer本身就需要额外的空间，大量的离屏渲染可能造成内存的过大压力，与此同时，Offscreen Buffer的总大小也有限，不能超过屏幕总像素的2.5倍。

可见离屏渲染的开销非常大，一旦需要离屏渲染的内容过多，很容易造成掉帧的问题。所以大部分情况下，我们都应该尽量避免离屏渲染。



#### 1.3 为什么使用离屏渲染

因为两种原因：

1. 一些特殊效果需要使用额外的Offscreen Buffer来保存渲染的中间状态，所以不得不使用离屏渲染。
2. 处于效率目的，可以将内容提前渲染保存在Offscreen Buffer中，达到复用的目的。

对于第一种情况，也就是不得不使用离屏渲染的情况，一般都是系统自动触发的，比如阴影、圆角等等。

最常见的情形就是使用了mask蒙版或者使用了模糊特效。

mask蒙版最终的内容是由两层渲染结果叠加，所以必须要利用额外的内存空间对中间的渲染结果进行保存，因此系统会默认触发离屏渲染。

模糊特效的过程：先渲染需要模糊的内容本身，对内容进行缩放，对缩放的内容进行横纵方向的模糊操作，最后一步用模糊后的结果叠加合成，最终实现完整的模糊特效。

为了复用提高效率而使用离屏渲染一般是主动的行为，是通过CALayer的shouldRasterize光栅化操作实现的。



#### 1.4 圆角离屏渲染

实际上并不是设置了圆角就会触发离屏渲染，是有条件的。

在苹果文档中的描述：

> Setting the radius to a value greater than 0.0 causes the layer to begin drawing rounded corners on its background. By default, the corner radius does not apply to the image in the layer’s contents property; it applies only to the background color and border of the layer. However, setting the masksToBounds property to true causes the content to be clipped to the rounded corners.

当设置cornerRadius大于0时，只为layer的backgroundColor和border设置圆角，而不是对layer的contents设置圆角，除非同时设置了layer.masksToBounds为true（UIView中的clipsToBounds属性）。

但设置了layer.masksToBounds为true也不一定会触发离屏渲染